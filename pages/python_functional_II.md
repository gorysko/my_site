title: Functional Python . Part II
date: 2013-09-20
type: post

Функції, як об’єкти першого класу
=================================

Ми вже начебто побачили, що функції є обєктами першого клсу в Python - справа в тому , що створивши об’єкт функції lambda - ми привязали наш обєкт до імен foo та namenum  ( все одно , що привязувати до імені стрічку чи число ), але точно так же як і число, чи стрічку можна використовувати без прив’язки до зімнної то ми можемо створювати об’єкт lambda без привязки до змінної - бо ці функції , всього лиш ще одне значення, з якими можна щось зробити :)

Найголовніше, для нас, що ми можемо зробити з об’єктами першого класу - так це передати їх до вбудованих функцій map(), reduce() та filter(). Кожна з цих функцій приймає обєкт функції ( перепрошую за тафталогію ), як перший аргумент
* map() застосовує передану функцію до кожного елемнту в переданому списку ( ну може і списків ...) та повертає список результатів.
 `map(foo(), [val1,val2,...val])`
* reduce() застосовує передану функцію до кожного значення в переданому списку і до внутрішнього накопчувачу реультату,наприклад:
  `reduce(lambda n,m:n*m, range(1,10))` означає 10! .
* filter() застосовує передану функцію до кожного елементу списку і повертає список тих елементів, для яких значення функцієї є істинним.

Комбінуючи три цих вбудованих функції ми можемо уникати statements, а використовувати лише вислови з цимифункціями. 

Функціональні цикли в Python
============================

Заміна циклів на вислови є доволі простим ділом, майже таким самим , як і заміна умовних блоків ( блоків управління потоком ). Наприклад for може бути напряму переведеним в map():

`
for e in lst:  func(e)      # statement-based loop
map(func,lst)           # map()-based loop
`

Якщо ж нам треба відтворити виконання послідовних висловів - " зроби це, потім це, а потім ще це", то з використанням map() буде виглядати так:
`
* створимо функцію, яка запускає інші функції ( знову тафталогія )
foo = lambda f: f()

* нехай f1, f2, f3 будуть нашими функціями 

map(foo, [f1,f2,f3])   # map()-based action sequence
`
Тобто загалом вся наша програма може бути викликана map() зі списком функцій, які треба послідовно викликати, так як функції ви можете помістити як список - вони ж є об’єктом  :)

Окремий пункт - цикл while в Python
-----------------------------------

`
* стандартний while  
while <cond>: 
	<pre-suite> i
	f <break_condition>: 
		break 
	else: 
		<suite> 
* функціональний 
def while_block(): 
	<pre-suite> 
	if <break_condition>: 
		return 1 
	else: 
		<suite> 
		return 0 
while_FP = lambda: (<cond> and while_block()) or while_FP() while_FP()
`
Цей функціональний варіат все ще не є досконалим - так як він потребує функцію while_block(), яка сама по собі може містити не тільки вислови , але і statements. Ми могли б збочуватися і далі - замінивши if/else на коротко замкнуті висловиб та й звичайна перевірка на місті <cond> , не завжди є корисною так як тіло циклу не може міняти змінні.

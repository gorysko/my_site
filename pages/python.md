title: Functional Python . Part I
date: 2013-09-19
type: post

Розповідати про саме функціональне програмування, та з чим його їдять я не буду - є дуже
багато літератури в неті по цій темі. Краще я зосереджусь на питанні -
функціонального програмування на Python.

Отже - функціональні можливості присутні в Python
=================================================
Python підтримує врізану частину функціонального програмування, фунції  map(), reduce(), filter() та оператор lambda - мають досить обмежені можливості використання, особливе місце для мене
займають ще й list comprehensions, хоча й відношення до функціонального програмування має мале, але дуже полегшує роботу та програмуванн в цілому
Синтаксис Python  є досить зручним навіть для використання таких врізаних можливостей - наприклад всі основні керуючі елементи (if, elif, else, assert, try, except, finally, for, break, continue, while, def)
можна представити в функціональному стилі, використовуючи лише функції та оператори. Хоча потім код буде мало чим відмінний від ліспового.


Виключення команд керування потоком
===================================

Перше. про ще треба пам’ятати - це те , що Python створює так званне "коротке замикання"
Ось як буде виглядати еквівалент блоку if/ elif/ else :

       `
	   Normal statement-based flow control
  	   if <cond1>: func1() elif <cond2>: func2() else: func3()
   	   Equivalent "short circuit"
  	   expression (<cond1> and func1()) or (<cond2> and func2()) or (func3())
	   Example "short circuit" expression
	     x = 3
	     def foo(s): return s
	     (x==1 and foo('one')) or (x==2 and foo('two')) or (foo('other'))
	     x = 2
	     (x==1 and foo('one')) or (x==2 and foo('two')) or (foo('other'))
	   `

Дуже красиво? Правда?
А якщо згадати, що lambda може приймати лише, підкреслюю - лише функції,
та подивившись на те, що написано згори ми бачимо, що наші записані в блоки, використовуючи коротке замикання,
то використовуючи lambda можемо трохи переписати наш вираз:

         `
	   foo = lambda s:s
	   namenum = lambda x: (x==1 and foo("one")) or (x==2 and foo("two")) or (foo("other"))
	   namenum(1)
	   namenum(2)
	   namenum(3)
   	  `
Продовження буде
----------------
